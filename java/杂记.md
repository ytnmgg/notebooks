1. JVM
   1.1 java内存模型
    https://blog.csdn.net/javazejian/article/details/72772461
    https://zhuanlan.zhihu.com/p/519803985

    java内存区域：堆、方法区（包含常量池）、栈区（本地方法栈、JVM栈）、程序计数器
    java内存模型JMM：抽象概念，分为主内存和各个线程的工作内存 ，线程从主内存拷贝共享变量到工作内存中处理后再写回主内存

    1.2 垃圾回收：
    https://blog.csdn.net/qq_35246620/article/details/80522720
    标记-清除、标记-整理（老年代）、复制法（青年代）
    查看GC器：java -XX:+PrintCommandLineFlags -version (默认ParNew+CMS)

    1.3 JVM参数设置（调优）
    https://blog.csdn.net/v123411739/article/details/123778478
    -Xms、-Xmx 堆初始、最大内存，设置到host内存3/4，设置成一样的值，避免动态伸缩带来的性能损失（空间不够向操作系统申请的时候还会发生GC）
    -Xmn 新生代大小 设置到整个堆大小的 3/8
    -XX:NewRatio=2，年轻代:老年代=1:2
    -XX:SurvivorRatio=8，eden:survivor=8:1 

    每次YGC耗时在100ms以内，50ms以内尤佳
    FGC最多几小时1次，1天不到1次尤佳
    每次FGC耗时在1s以内，500ms以内尤佳

   1.4 类创建流程
   https://blog.csdn.net/justloveyou_/article/details/72466105
   https://blog.csdn.net/justloveyou_/article/details/72466416

   生命周期：加载-验证-准备-解析-初始化-使用-卸载

   初始化步骤：1. 父类的静态变量 -> 2. 父类的静态代码块 -> 3. 子类的静态变量 -> 4. 子类的静态代码块 -> 5. 父类的非静态变量 -> 6. 父类的非静态代码块 -> 7. 父类的构造函数 -> 8. 子类的非静态变量 -> 9. 子类的非静态代码块 -> 10. 子类的构造函数
   https://zhuanlan.zhihu.com/p/556031463

   1.5 对象创建流程
   https://blog.csdn.net/justloveyou_/article/details/72466416
   
   父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数 -> 子类的成员变量和实例代码块 -> 子类的构造函数。

   推荐：
   https://blog.csdn.net/q160336802/article/details/123054729

   类加载 -> 内存分配(指针碰撞、空闲列表) -> 初始化默认值 -> 设置对象头 -> 执行初始化方法

1. synchronized的底层原理
   https://blog.csdn.net/weixin_42460087/article/details/126474481
   https://www.cnblogs.com/wffzk/p/16639472.html

   对象header、mark word、ObjectMonitor对象
   底层依赖操作系统的mutex lock、汇编原子命令xchgb
   https://blog.csdn.net/lengxiao1993/article/details/81568130
   https://blog.csdn.net/A_BCDEF_/article/details/89436705


3. JDK 动态代理、为什么只能基于接口做代理
    https://juejin.cn/post/6874916520179269639
    https://www.jianshu.com/p/471c80a7e831

    InvocationHandler接口、Proxy类

4. ArrayList和LinkedList区别
   https://cloud.tencent.com/developer/news/700913
   https://blog.csdn.net/qing_gee/article/details/107531949

5. ArrayList非线程安全的解决办法
    https://blog.csdn.net/xsjzn/article/details/124361000

    Collections.synchronizedList()、CopyOnWriteArrayList

6. HashMap的resize流程
   https://blog.csdn.net/cy973071263/article/details/122869909
   https://blog.csdn.net/weixin_39667787/article/details/86678215

7. ConcurrentHashMap CAS+synchronized


8. spring 解决循环依赖
   https://mp.weixin.qq.com/s/0OD75CzV5uTW69Y9zOEhtA

   https://blog.csdn.net/weixin_44102992/article/details/128106055


   为什么要3级缓存解决循环依赖：
   理论上2级就够了，一个放完整对象，一个放半成品对象（未初始化及设置属性）
   但是涉及到AOP，就不够了：
      正常AOP，是在bean初始化之后进行的，spring框架会把代理后的对象放到spring上下文，替换原有对象
      但是属性引用到这个对象的其它对象怎么办，因为属性是一个地址引用，最直观的方法是遍历这些对象，把代理对象挨着去替换一遍

      这个操作看起来有点重，因为遍历bean的操作在前期refresh的时候就做了，没必要再做一遍
      所以，在这里依赖注入的时候，就提前把代理对象给设置到属性上去了（三级缓存返回的），而不是设置原始对象，这样后期就不用遍历所有bean去设置了

      那如果这个第三级缓存是生成代理对象的，如果对象A依赖B/C，B/C同时又依赖A，B调用三级缓存的工厂生成A的代理了，C又来调用一遍，就生成2个代理了，
      所以需要给这个第三级缓存再加一个缓存：没生成过就调用工厂生成，生成过的，就直接从缓存拿。 这个第三级缓存的缓存，就是第二级缓存了。

      所以总共需要三级缓存


9. spring bean 生命周期
    https://blog.csdn.net/weixin_44145478/article/details/120217272


10. spring 事务原理
   https://blog.csdn.net/weixin_51423778/article/details/128226788

   https://www.zhengw-tech.com/2020/03/29/spring-transaction/

   流程：
   1. 利用所配置的PlatformTransactionManager事务管理器获取一个数据库连接
   2. 修改数据库连接的autocommit为false
   3. 执行业务方法（）TransactionCallback.doInTransaction
   4. 如果没有抛异常，则提交 / 如果抛了异常，则回滚

   底层原理：
   接口：PlatformTransactionManager -> JDBC实现：DataSourceTransactionManager -> 用到：TransactionSynchronizationManager -> 用到：ThreadLocal
      -> ThreadLocal保存：ConnectionHolder -> ConnectionHolder判断是否有激活态的事务，处理不同的传播级别


11. redis
   11.1 redis 分布式锁
   https://blog.csdn.net/scm_2008/article/details/127422698

      1. 普通： setnx key value 返回1成功，0失败； del key 释放锁
      2. 解决服务宕机，无法释放：setnx key value; expire key 60
      3. 2中两条命令不是原子的，还是有可能执行了setnx之后没来得及执行expire就宕机了，解决方式是用lua脚本保障原子性：
          String lua_scripts = "if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end";
          jedis.eval(lua_scripts, key, value, 60);
      4. redis2.6开始支持原子命令：set key value ex 60 nx
      5. del key 可能误删别人的（场景：线程1拿锁执行业务，超过了expire时间，锁自动释放；线程2拿到锁，正在进行业务；线程1执行完成业务，删锁，实际上是线程2的锁被释放了；线程3过来又拿到了锁，和线程2同时进行业务，资源冲突）
      6. 5的解法：value中保存线程唯一id，线程去解锁的时候，判断id是否一致（是否不是自己的锁），再决定是否删除
      7. 6又出现了原子性，get id和del key不是原子的，又得用lua脚本保障原子性：
         String lua_scripts = "if (redis.call('get', KEYS[1]) == ARGV[1] ) then redis.call('del', KEYS[1]); return 1; end; return 0;";
         jedis.eval(lua_scripts, key, value);

   11.2 redis zset 定时关单
      1. zadd key score value : key=表名，score=单据应该过期的时间戳（创建时间+过期间距），value=单据id
      2. zrangebyscore key min max withscores LIMIT offset count: 
         min=0，max=当前时间戳，则过期时间小于当前时间的单据都能捞出来，offset=0 count=100：一次从头捞100个
      3. zrem key value: 执行业务单据过期操作以后，删除value=id的reids记录 
         或者批量删：zremrangebyscore key min max
      注意上面2~3步骤，需要加分布式锁

   11.3 redis限流
      方法1：zset时间窗
      1. 访问一次就添加一条记录：zadd key score value: key=uid, score=当前时间戳，value=当前时间戳
      2. 删除时间窗口外面的记录：zremrangebyscore key min max: key=uid, min=0, max=当前时间戳-窗口大小（比如：1000=1秒）
      3. 统计窗口内的条数：zcard key: key=uid，判断count和限流值大小关系，决定是否丢弃当前请求

      方法2：incr and expire
      https://redis.com/glossary/rate-limiting/
      1. get key: key=uid:minute，即key由uid+当前分钟数组成，比如xxxx:3，表示xxxx用户第3分钟的访问次数
      2. 如果值存在，且大于限流值，比如20，则抛限流异常
      3. incr key; expire key 59： 加一，且1分钟后过期
         注意：上面方法，incr key，如果key不存在，那么key的值会先被初始化为0，然后再执行 INCR 操作，即始终会设置值为1，不会报错

      方法3：令牌桶
      令牌桶和漏捅区别：

      瞬时速率：如果在一瞬间有很多请求进来，此时来不及产生令牌，则在一瞬间最多只有n个请求能获取到令牌执行业务逻辑，所以令牌桶算法也可以控制瞬时速率
               漏桶由于出水量固定，所以无法应对突然的流量爆发访问，也就是没有保证瞬时速率的功能，但是可以保证平均速率
      场景：漏桶更适用于“秒杀、抢购、热点时间”等场景，因为这种场景用漏桶的话是先缓存请求，但是令牌桶则是先丢弃请求，会造成大量报错

      lua 脚本:
      ```lua
         local current_time=tonumber(ARGV[1]) -- 当前时间（毫秒时间戳）
         local capacity = 100   -- 桶容量，也作为每秒生成token的个数，即QPS
         local required_amount = 1  -- 单次取几个

         -- 当前令牌数
         curr_amount = redis.call('get', 'bucket_limit')
         -- 下一次有token可用的时间（毫秒时间戳）
         next_time = redis.call('get', 'next_time')

         -- 情况一：桶不存在、或者过期，重新生成桶和过期时间，且返回未限流结果
         if (curr_amount==false or last_time==false) then
            redis.call('set', 'bucket_limit', capacity - required_amount, 'EX', 60)
            redis.call('set', 'next_time', current_time, 'EX', 60)
            return 0 -- 未触发限流
         end

         -- 情况二：触发限流判断：还没到下一次有token可用的时间
         if (next_time > current_time) then
            return 1 -- 触发限流
         end

         -- 情况三： 未触发限流，更新token数量和下一次有token可用的时间
         -- 根据和上一次时间比较，更新生成新的token
         interval = 1000 / capacity -- token生成间隔（毫秒），capacity是每秒token数，则1000/capacity就是产生两个token之间的时间间隔
         created_amount = (current_time - next_time) / interval
         new_amount = curr_amount + created_amount
         if (new_amount > capacity) then
            curr_amount = capacity
         else
            curr_amount = new_amount

         -- 减去这次需要的token，更新剩余token和下一次有token可用的时间
         need_amount = 0
         if (curr_amount < required_amount) then
            need_amount = required_amount - curr_amount -- 距离需要的token数量，还差几个
         else
            curr_amount = curr_amount - required_amount -- 还剩几个
         end

         wait_time = need_amount * interval -- 距离需要的token数量，还需要等多久
         next_time = current_time + wait_time -- 下一次有token可用的时间（毫秒时间戳）

         redis.call('set', 'bucket_limit', curr_amount, 'EX', 60)
         redis.call('set', 'next_time', next_time, 'EX', 60)

         return 0 -- 未触发限流 

      ```